<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AVR32 - FAT Services: Accelerate multi write file</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Accelerate multi write file<br>
<small>
[<a class="el" href="a00057.html">Examples</a>]</small>
</h1><dl class="user" compact><dt><b>Overview</b></dt><dd>The routines <a class="el" href="a00028.html#952fd54b2e49943d138e44d3bdf569bf">file_getc()</a> and <a class="el" href="a00028.html#44de4bc08663fbddbd11946bbb06e2ce">file_putc()</a> are too slow to transfer many data.<br>
 <br>
 The <a class="el" href="a00028.html#7b7c08bde8cb93a792dd578cf4310d0a">file_read_buf()</a> and <a class="el" href="a00028.html#415ad1a43ac79c02c294a4e32246c519">file_write_buf()</a> are developed to transfer many data between the RAM and file on a memory.<br>
 This routines optimize the transfer and if a DMA exists between RAM and memory then it is used.<br>
 <br>
 The <a class="el" href="a00028.html#d0fc50dbdd1849e9fe0e81b215ce9335">file_read()</a> and <a class="el" href="a00028.html#1b5c29ddedddd73a1279b9920ea1642f">file_write()</a> are developed to transfer many data between a file and another memory or a specific interface.<br>
 This routines don't transfer data, but provide an information on the disk segment corresponding to the file.<br>
 Overside, it is not necessary to transfer data in the RAM and the chip can use a DMA between two disks to save time.<br>
 <br>
 In case of many "file_write_buf() or file_putc()" call (e.g. log file), the execution may be slow because the number of write access on the disk is important. So, the following section gives a solution to accelerate the execution and reduces the number of write access.<br>
 <br>
 Also, it is important to know that FAT time creation depends of FAT type used. The allocation in FAT is more fast on FAT (FAT12,FAT16) than FAT32. If you have a disk size &lt; 2GB then you can force the type FAT when you call nav_drive_format(FS_FORMAT_FAT).<br>
 <br>
 Also, you can call <a class="el" href="a00047.html#c7a2bc65b27a1d7a449d18b07fde6629">nav_checkdisk_disable()</a> before many file IN/OUT routines access.<br>
 Because the "test unit ready" routine can reduce the speed of IN/OUT routines.</dd></dl>
<dl class="user" compact><dt><b>Examples</b></dt><dd></dd></dl>
If you write many data in a file and you split the write access (e.g. log file), then it may be interresting to prealloc once the space in file (FAT table).<p>
This example is the usual sequence to fill a file :<br>
 <div class="fragment"><pre class="fragment"><span class="comment">// File fill &gt;1MB</span>
<span class="preprocessor">#define  FILL_FILE_NB_WRITE   855L</span>
<span class="preprocessor"></span><span class="preprocessor">#define  FILL_FILE_BUF_SIZE   120L</span>
<span class="preprocessor"></span>
Bool fill_file( <span class="keywordtype">void</span> )
{
   <span class="keyword">const</span> <a class="code" href="a00031.html#bce1d65796e24ba2337201b579bc874e">UNICODE</a> _MEM_TYPE_SLOW_ name[50]={<span class="charliteral">'l'</span>,<span class="charliteral">'o'</span>,<span class="charliteral">'g'</span>,<span class="charliteral">'.'</span>,<span class="charliteral">'b'</span>,<span class="charliteral">'i'</span>,<span class="charliteral">'n'</span>,0};
   U16 u16_nb_write;

   memset( g_trans_buffer , 0x55 , FILL_FILE_BUF_SIZE );
   
   <span class="keywordflow">if</span>( !<a class="code" href="a00047.html#dd247ba4e5086c74c6f106a55617872a" title="This function selects a drive in navigator but don&amp;#39;t mount the disk partition...">nav_drive_set</a>(LUN_DISK))    <span class="comment">// Enter in disk</span>
      <span class="keywordflow">return</span> FALSE;
   <span class="keywordflow">if</span>( !<a class="code" href="a00047.html#aa10a2b4e4db0e4eb602b19b4f9ff9b9" title="This function mounts the selected partition.">nav_partition_mount</a>())      <span class="comment">// Mount partition of disk</span>
      <span class="keywordflow">return</span> FALSE;
   
   <span class="keywordflow">if</span>( !<a class="code" href="a00047.html#27b550ee0cf2326498755b429818b145" title="This function creates a file with NULL size and NULL attribut.">nav_file_create</a>( (<span class="keyword">const</span> <a class="code" href="a00031.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a>) name )) <span class="comment">// Create file  </span>
      <span class="keywordflow">return</span> FALSE;
   <span class="keywordflow">if</span>( !<a class="code" href="a00028.html#310a118fba8ffb01c998e5087f32d815" title="This function opens the selected file.">file_open</a>(<a class="code" href="a00031.html#13bd4ac29f28eacba5dd3e908be04234" title="W access, flux pointer = 0, size = 0.">FOPEN_MODE_W</a>))    <span class="comment">// Open file in write mode with force file size 0</span>
      <span class="keywordflow">return</span> FALSE;
   
   <span class="keywordflow">for</span>( u16_nb_write=0; u16_nb_write&lt;FILL_FILE_NB_WRITE; u16_nb_write++ )
   {
      <span class="comment">// HERE, at each write file, a allocation in FAT area is run</span>
      <span class="comment">// so, if you have many buffer to write the execution may be slow.</span>
      <span class="keywordflow">if</span>( !<a class="code" href="a00028.html#415ad1a43ac79c02c294a4e32246c519" title="This function transfer a buffer to a file at the current file position.">file_write_buf</a>( g_trans_buffer , FILL_FILE_BUF_SIZE ))
      {
         <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();
         <span class="keywordflow">return</span> FALSE;
      }
   }
   <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();
   <span class="keywordflow">return</span> TRUE;
}
</pre></div><p>
This example allow to accelerate write access with a prealloc routine : <div class="fragment"><pre class="fragment"><span class="comment">// File fill &gt;1MB</span>
<span class="preprocessor">#define  FILL_FILE_NB_WRITE   855L</span>
<span class="preprocessor"></span><span class="preprocessor">#define  FILL_FILE_BUF_SIZE   120L</span>
<span class="preprocessor"></span>
Bool fill_file_fast( <span class="keywordtype">void</span> )
{
   <span class="keyword">const</span> <a class="code" href="a00031.html#bce1d65796e24ba2337201b579bc874e">UNICODE</a> _MEM_TYPE_SLOW_ name[50]={<span class="charliteral">'l'</span>,<span class="charliteral">'o'</span>,<span class="charliteral">'g'</span>,<span class="charliteral">'_'</span>,<span class="charliteral">'f'</span>,<span class="charliteral">'a'</span>,<span class="charliteral">'s'</span>,<span class="charliteral">'t'</span>,<span class="charliteral">'.'</span>,<span class="charliteral">'b'</span>,<span class="charliteral">'i'</span>,<span class="charliteral">'n'</span>,0};
   _MEM_TYPE_SLOW_ <a class="code" href="a00007.html">Fs_file_segment</a> g_recorder_seg;
   U16 u16_nb_write;
   
   memset( g_trans_buffer , 0x55 , FILL_FILE_BUF_SIZE );

   <span class="keywordflow">if</span>( !<a class="code" href="a00047.html#dd247ba4e5086c74c6f106a55617872a" title="This function selects a drive in navigator but don&amp;#39;t mount the disk partition...">nav_drive_set</a>(LUN_DISK))    <span class="comment">// Enter in disk</span>
      <span class="keywordflow">return</span> FALSE;
   <span class="keywordflow">if</span>( !<a class="code" href="a00047.html#aa10a2b4e4db0e4eb602b19b4f9ff9b9" title="This function mounts the selected partition.">nav_partition_mount</a>())      <span class="comment">// Mount partition of disk</span>
      <span class="keywordflow">return</span> FALSE;
   
   <span class="keywordflow">if</span>( !<a class="code" href="a00047.html#27b550ee0cf2326498755b429818b145" title="This function creates a file with NULL size and NULL attribut.">nav_file_create</a>( (<span class="keyword">const</span> <a class="code" href="a00031.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a>) name )) <span class="comment">// Create file  </span>
      <span class="keywordflow">return</span> FALSE;
   <span class="keywordflow">if</span>( !<a class="code" href="a00028.html#310a118fba8ffb01c998e5087f32d815" title="This function opens the selected file.">file_open</a>(<a class="code" href="a00031.html#13bd4ac29f28eacba5dd3e908be04234" title="W access, flux pointer = 0, size = 0.">FOPEN_MODE_W</a>))    <span class="comment">// Open file in write mode and forces the file size to 0</span>
      <span class="keywordflow">return</span> FALSE;
   
   <span class="comment">// Define the size of segment to prealloc (unit 512B)</span>
   <span class="comment">// Note: you can alloc more in case of you don't know total size</span>
   g_recorder_seg.u16_size = (FILL_FILE_NB_WRITE*FILL_FILE_BUF_SIZE + 512L)/512L;

   <span class="comment">// ****PREALLLOC****** the segment to fill</span>
   <span class="keywordflow">if</span>( !<a class="code" href="a00028.html#1b5c29ddedddd73a1279b9920ea1642f" title="This function allocs and returns a segment (position &amp;amp; size) in a physical memory...">file_write</a>( &amp;g_recorder_seg ))
   {
      <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();
      <span class="keywordflow">return</span> FALSE;
   }

   <span class="comment">// Check the size of segment allocated</span>
   <span class="keywordflow">if</span>( g_recorder_seg.u16_size &lt; ((FILL_FILE_NB_WRITE*FILL_FILE_BUF_SIZE + 512L)/512L) )
   {
      <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();
      <span class="keywordflow">return</span> FALSE;
   }

   <span class="comment">// Close/open file to reset size</span>
   <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();                    <span class="comment">// Closes file. This routine don't remove the previous allocation.</span>
   <span class="keywordflow">if</span>( !<a class="code" href="a00028.html#310a118fba8ffb01c998e5087f32d815" title="This function opens the selected file.">file_open</a>(<a class="code" href="a00031.html#13bd4ac29f28eacba5dd3e908be04234" title="W access, flux pointer = 0, size = 0.">FOPEN_MODE_W</a>))    <span class="comment">// Opens file in write mode and forces the file size to 0</span>
      <span class="keywordflow">return</span> FALSE;

   <span class="keywordflow">for</span>( u16_nb_write=0; u16_nb_write&lt;FILL_FILE_NB_WRITE; u16_nb_write++ )
   {
      <span class="comment">// HERE, the file cluster list is already allocated and the write routine is more fast.</span>
      <span class="keywordflow">if</span>( !<a class="code" href="a00028.html#415ad1a43ac79c02c294a4e32246c519" title="This function transfer a buffer to a file at the current file position.">file_write_buf</a>( g_trans_buffer , FILL_FILE_BUF_SIZE ))
      {
         <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();
         <span class="keywordflow">return</span> FALSE;
      }
   }
   <a class="code" href="a00028.html#7f4f3b65455595cb5be0f7cd7d12e02d" title="This function closes the file.">file_close</a>();
   <span class="keywordflow">return</span> TRUE;
}
</pre></div><p>
<dl class="user" compact><dt><b>Statistic</b></dt><dd></dd></dl>
A FAT32 has need to write more (x4) sectors in FAT table than FAT16 for the same file size and same disk size.<p>
Create a file of 100.2KB (buffer 120B * nb write 855) on a disk 256MB (FAT16-cluster 4KB):<ul>
<li>with fill_file() , the write access on a same sector in FAT is <b>50 maximum and 25 average</b>.</li><li>with fill_filefast(), the write access on a same sector in FAT is <b>2 maximum and 1 average</b>.</li></ul>
<p>
Create a file of 1.1MB (buffer 120B * nb write 10000) on a disk 256MB (FAT16-cluster 4KB):<ul>
<li>with fill_file() , the write access on a same sector in FAT is <b>255 maximum and 147 average</b>.</li><li>with fill_filefast(), the write access on a same sector in FAT is <b>2 maximum and 1 average</b>. </li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Dec 21 18:30:26 2009 for AVR32 - FAT Services by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
